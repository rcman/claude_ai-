<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 3rd Person Survival World</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: sans-serif;}
        canvas { display: block; }
        #blocker, #settingsScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            font-size: 14px;
            z-index: 10;
        }
        #instructions {
             /* No longer needs cursor: pointer for lock */
        }
         /* Add a style to hide cursor when controls active */
        .controls-active {
            cursor: none;
        }
        #settingsScreen label, #settingsScreen input {
             display: block; margin: 10px auto; text-align: left; width: 200px;
        }
         #settingsScreen input[type="number"], #settingsScreen input[type="range"] { width: 100px; float: right; }
         #settingsScreen button { padding: 10px 20px; font-size: 16px; margin-top: 20px; cursor: pointer; }

        /* UI Elements */
        #uiContainer {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            top: 10px;
            color: white;
            pointer-events: none; /* Allow clicks to pass through to canvas */
            z-index: 5;
            font-family: monospace;
        }
        #quickBar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid grey;
        }
        .quickBarSlot {
            width: 50px;
            height: 50px;
            border: 1px solid grey;
            margin: 2px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            position: relative;
        }
         .quickBarSlot.selected { border: 2px solid yellow; }
         .itemCount {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background-color: rgba(0,0,0,0.7);
            padding: 1px 3px;
            border-radius: 3px;
            font-size: 10px;
         }

        #inventoryScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 700px;
            height: 70%;
            max-height: 500px;
            background-color: rgba(50, 50, 50, 0.9);
            border: 2px solid grey;
            display: none; /* Hidden by default */
            flex-direction: row; /* Changed for side-by-side layout */
            padding: 15px;
            box-sizing: border-box;
            pointer-events: auto; /* Enable interaction */
            z-index: 15;
            justify-content: space-between;
        }
        #inventoryGrid, #craftingPanel, #containerGrid { /* Added containerGrid */
             width: 45%; /* Adjust width for three panels if needed */
             height: 100%;
             overflow-y: auto;
             border: 1px solid grey;
             padding: 5px;
             box-sizing: border-box;
        }
        #craftingPanel { width: 30%; }
        #inventoryGrid { width: 35%; }
        #containerGrid { width: 30%; display: none; } /* Hidden by default */

        .inventorySlot, .craftingItem, .containerSlot { /* Added containerSlot */
            width: 60px;
            height: 60px;
            border: 1px solid dimgray;
            background-color: rgba(0,0,0,0.3);
            margin: 3px;
            display: inline-flex; /* Use inline-flex for grid */
            justify-content: center;
            align-items: center;
            font-size: 11px;
            position: relative;
            cursor: pointer;
            vertical-align: top;
        }
        .craftingItem {
            width: 95%;
            height: auto;
            padding: 5px;
            margin-bottom: 5px;
            text-align: left;
            display: block; /* List view for crafting */
            background-color: rgba(70,70,70,0.8);
        }
        .craftingItem button {
            float: right;
            font-size: 10px;
            padding: 2px 4px;
            cursor: pointer;
        }
        .craftingItem span { font-size: 10px; color: #ccc; display: block; }

        #interactionPrompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.6);
            padding: 8px 15px;
            border-radius: 5px;
            display: none; /* Hidden by default */
        }
         #messageLog {
             position: absolute;
             top: 10px;
             left: 10px;
             max-height: 150px;
             overflow-y: hidden;
             background-color: rgba(0,0,0,0.4);
             padding: 5px;
             width: 300px;
         }
         .logMessage { margin-bottom: 3px; font-size: 12px; }
    </style>
</head>
<body>
    <!-- Initial Settings Screen -->
    <div id="settingsScreen">
         <h2>Game Settings</h2>
         <form id="settingsForm">
             <label>Starting Wood: <input type="number" id="startWood" value="10" min="0"></label>
             <label>Starting Stone: <input type="number" id="startStone" value="10" min="0"></label>
             <label>Starting Food: <input type="number" id="startFood" value="5" min="0"></label>
             <label>Starting Scrap: <input type="number" id="startScrap" value="5" min="0"></label>
             <hr style="width: 200px; margin: 15px auto;">
             <label>Player Speed: <input type="range" id="playerSpeed" min="2" max="8" value="4" step="0.5"> <span id="speedValue">4.0</span></label> <!-- Changed scale for 3rd person -->
             <label>Player Height: <input type="range" id="playerHeight" min="1.0" max="3.0" value="1.8" step="0.1"> <span id="heightValue">1.8</span></label> <!-- Changed scale for 3rd person -->
             <button type="submit">Start Game</button>
         </form>
    </div>

    <!-- Blocker for initial instructions / Paused state -->
    <div id="blocker" style="display: none;"> <!-- Initially hidden -->
        <div id="instructions">
            <p style="font-size: 36px">Click to activate controls</p>
            <p>
                Move: WASD<br/>
                Jump: SPACE<br/>
                Look: MOUSE<br/>
                Interact: E<br/>
                Inventory: I <br> <!-- Changed from Tab -->
                Cycle Quickbar: 1-9<br/>
                (ESC to release controls)
            </p>
        </div>
    </div>

    <!-- UI Elements -->
    <div id="uiContainer">
        <div id="quickBar">
            <!-- Quick bar slots will be generated here -->
        </div>
        <div id="inventoryScreen">
             <div id="inventoryGrid"><h3>Inventory</h3> <!-- Slots added dynamically --> </div>
             <div id="craftingPanel"><h3>Crafting</h3> <!-- Items added dynamically --> </div>
             <div id="containerGrid"><h3>Container</h3> <!-- Slots added dynamically --></div>
        </div>
         <div id="interactionPrompt">Press [E] to interact</div>
         <div id="messageLog"></div>
    </div>

    <!-- Load Three.js core library from HTTP CDN -->
    <script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- PointerLockControls NOT needed anymore -->
    <!-- <script src="http://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/controls/PointerLockControls.js"></script> -->

    <script>
        // --- Three.js Setup ---
        let camera, scene, renderer /*, controls */; // Remove PointerLockControls reference
        let prevTime = performance.now();
        const worldScale = 200;

        // --- Player & Camera ---
        let playerMesh; // The visible player model
        const playerVelocity = new THREE.Vector3();
        const playerDirection = new THREE.Vector3(); // Direction player is moving
        const cameraOffset = new THREE.Vector3(0, 4, 7); // Initial camera offset (behind, above)
        const cameraLookAtOffset = new THREE.Vector3(0, 1.5, 0); // Point slightly above player base
        let cameraTargetPosition = new THREE.Vector3();
        let playerTargetYaw = 0; // Target rotation around Y axis
        let playerCurrentYaw = 0;
        let cameraPitch = 0.3; // Initial vertical angle
        const maxCameraPitch = Math.PI / 2 - 0.1; // Limit looking straight up/down
        const minCameraPitch = -Math.PI / 4;
        let mouseSensitivity = 0.002;
        let controlsActive = false; // Track if mouse controls camera

        // --- Game State & Settings ---
        let gameStarted = false;
        let playerSettings = {
            speed: 4.0,
            height: 1.8, // Player model height
            radius: 0.4, // Player model radius
            jumpHeight: 8.0, // Adjusted jump force
            interactionDistance: 5.0
        };
        let playerInventory = {}; // { itemName: count, ... }
        let quickBar = [null, null, null, null, null, null, null, null, null]; // 9 slots
        let selectedQuickBarSlot = 0;
        let inventoryOpen = false;
        let currentlyInteractingWith = null; // Reference to the world object being interacted with
        let currentContainerLoot = null; // Loot in the container being viewed

        const recipes = {
            'Rope': { ingredients: { 'Tall Grass': 3 }, output: { 'Rope': 1 } },
            'Axe': { ingredients: { 'Wood': 5, 'Stone': 3, 'Rope': 1 }, output: { 'Axe': 1 } },
            'Pickaxe': { ingredients: { 'Wood': 5, 'Stone': 3, 'Rope': 1 }, output: { 'Pickaxe': 1 } },
            'Campfire': { ingredients: { 'Wood': 10, 'Stone': 5 }, output: { 'Campfire': 1 } },
            'Crafting Table': { ingredients: { 'Wood': 15 }, output: { 'Crafting Table': 1 } },
            'Forge': { ingredients: { 'Stone': 20, 'Wood': 5 }, output: { 'Forge': 1 } }, // Simplified
            'Cooked Meat': { ingredients: { 'Raw Meat': 1 }, output: { 'Cooked Meat': 1 }, requires: 'Campfire' }, // Example cooking
            'Purified Water': { ingredients: { 'Dirty Water': 1 }, output: { 'Purified Water': 1 }, requires: 'Campfire' }, // Example purification
        };

        // --- World Objects & Interaction ---
        const worldObjects = []; // Stores { mesh: THREE.Mesh, type: string, data: {} }
        const collidableObjects = []; // Meshes for collision detection
        const animals = []; // Stores { mesh: THREE.Mesh, state: 'idle'/'wandering', target: Vector3 }
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2(); // For potential UI interaction, not camera
        let INTERSECTED; // The object the player is currently looking at within range

        // --- DOM Elements ---
        const blocker = document.getElementById( 'blocker' );
        const instructions = document.getElementById( 'instructions' );
        const settingsScreen = document.getElementById( 'settingsScreen' );
        const settingsForm = document.getElementById( 'settingsForm' );
        const uiContainer = document.getElementById( 'uiContainer' );
        const quickBarDiv = document.getElementById( 'quickBar' );
        const inventoryScreen = document.getElementById( 'inventoryScreen' );
        const inventoryGrid = document.getElementById( 'inventoryGrid' );
        const craftingPanel = document.getElementById( 'craftingPanel' );
        const containerGrid = document.getElementById( 'containerGrid' ); // Get container grid element
        const interactionPrompt = document.getElementById( 'interactionPrompt' );
        const messageLog = document.getElementById('messageLog');

        // --- Initialization ---
        setupSettingsScreen(); // Setup settings form listener first

        function setupSettingsScreen() {
            // Update displayed values for range inputs
             const speedInput = document.getElementById('playerSpeed');
             const speedValueSpan = document.getElementById('speedValue');
             const heightInput = document.getElementById('playerHeight');
             const heightValueSpan = document.getElementById('heightValue');

             speedInput.oninput = () => speedValueSpan.textContent = parseFloat(speedInput.value).toFixed(1);
             heightInput.oninput = () => heightValueSpan.textContent = parseFloat(heightInput.value).toFixed(1);

            settingsForm.addEventListener('submit', (e) => {
                e.preventDefault();
                playerSettings.speed = parseFloat(speedInput.value);
                playerSettings.height = parseFloat(heightInput.value); // This is visual height now
                playerSettings.radius = playerSettings.height * 0.22; // Adjust radius based on height
                 playerSettings.jumpHeight = playerSettings.speed * 2; // Scale jump with speed

                // Set initial resources
                addItemToInventory('Wood', parseInt(document.getElementById('startWood').value));
                addItemToInventory('Stone', parseInt(document.getElementById('startStone').value));
                addItemToInventory('Raw Meat', parseInt(document.getElementById('startFood').value)); // Example starting food
                addItemToInventory('Scrap Metal', parseInt(document.getElementById('startScrap').value));

                 // Give starting tools
                 addItemToInventory('Axe', 1);
                 addItemToInventory('Pickaxe', 1);
                 addItemToInventory('Knife', 1); // Assume knife is for hunting
                 addItemToInventory('Canteen', 1); // Holds water - needs state (dirty/clean)

                // Move starting tools to quick bar if possible
                 moveToQuickBar('Axe');
                 moveToQuickBar('Pickaxe');
                 moveToQuickBar('Knife');
                 moveToQuickBar('Canteen');

                settingsScreen.style.display = 'none';
                blocker.style.display = 'flex'; // Show blocker instructions
                gameStarted = true;
                init();
                animate();
            });
        }


        function init() {
            // 1. Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0x87CEEB );
            scene.fog = new THREE.Fog( 0x87CEEB, 50, worldScale * 0.75 ); // Start fog further away

            // 2. Camera
            camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
            // Camera position will be set dynamically in animate() relative to player

            // 3. Renderer
            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild( renderer.domElement );

            // 4. Lights (Same as before)
            const ambientLight = new THREE.AmbientLight( 0xcccccc, 0.5 ); // Slightly brighter ambient
            scene.add( ambientLight );
            const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.9 ); // Slightly brighter directional
            directionalLight.position.set( 50, 200, 100 );
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
             directionalLight.shadow.camera.left = -worldScale * 0.6;
             directionalLight.shadow.camera.right = worldScale * 0.6;
             directionalLight.shadow.camera.top = worldScale * 0.6;
             directionalLight.shadow.camera.bottom = -worldScale * 0.6;
            scene.add( directionalLight );
            // scene.add( new THREE.CameraHelper( directionalLight.shadow.camera ) );

            // 5. Player Model
            createPlayerModel();

            // 6. Controls Input Listeners (No PointerLockControls)
            blocker.addEventListener( 'click', () => {
                controlsActive = true;
                blocker.style.display = 'none';
                document.body.classList.add('controls-active'); // Hide cursor
            });

            // Listen for mouse movement for camera rotation
             document.addEventListener('mousemove', onMouseMove);
             document.addEventListener('keydown', onKeyDown);
             document.addEventListener('keyup', onKeyUp);

            // Add ESC listener to release controls
            document.addEventListener('keydown', (event) => {
                if (event.code === 'Escape') {
                    controlsActive = false;
                    inventoryOpen = false; // Also close inventory on Esc
                    inventoryScreen.style.display = 'none';
                    blocker.style.display = 'flex'; // Show instructions/pause overlay
                    document.body.classList.remove('controls-active'); // Show cursor
                }
            });


            // 7. World Elements
            createGround();
            createTrees(30);
            createRocks(50);
            createBarrels(15);
            createBuildings(5); // Will place crates inside
            createWaterBodies(3);
            createAnimals(10);
            createTallGrass(100);
            createScrapMetal(20);

            // 8. UI Initialization
            updateQuickBarUI();
            updateInventoryUI();
            updateCraftingUI();

            // --- Event Listeners ---
            window.addEventListener( 'resize', onWindowResize );
        }

        // --- Input Handling ---
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false, isJumping = false;

         function onMouseMove(event) {
             if (!controlsActive || inventoryOpen) return;

             const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
             const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

             playerTargetYaw -= movementX * mouseSensitivity;
             cameraPitch -= movementY * mouseSensitivity;

             // Clamp vertical rotation
             cameraPitch = Math.max(minCameraPitch, Math.min(maxCameraPitch, cameraPitch));
         }

        function onKeyDown ( event ) {
            if (event.code === 'Escape') return; // Handled separately

            // Allow Inventory toggle even if controls aren't active
             if (event.code === 'KeyI') {
                 event.preventDefault(); // Prevent browser inventory search etc.
                 toggleInventory();
                 return;
             }

             if (!controlsActive || inventoryOpen) return; // Ignore movement if controls inactive or inventory open

            switch ( event.code ) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'Space': if ( canJump ) isJumping = true; break; // Set flag to jump on next physics update
                case 'KeyE': handleInteraction(); break;
                 // Quickbar selection
                case 'Digit1': selectQuickBarSlot(0); break;
                case 'Digit2': selectQuickBarSlot(1); break;
                case 'Digit3': selectQuickBarSlot(2); break;
                case 'Digit4': selectQuickBarSlot(3); break;
                case 'Digit5': selectQuickBarSlot(4); break;
                case 'Digit6': selectQuickBarSlot(5); break;
                case 'Digit7': selectQuickBarSlot(6); break;
                case 'Digit8': selectQuickBarSlot(7); break;
                case 'Digit9': selectQuickBarSlot(8); break;
            }
        };

        function onKeyUp ( event ) {
            if (!controlsActive) return; // Ignore if controls inactive

            switch ( event.code ) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
                 // Note: Jump flag (isJumping) is reset in the movement logic after applying force
            }
        };

        // --- Object Creation Functions ---

        function createPlayerModel() {
             // Simple capsule: cylinder + sphere top/bottom
             const radius = playerSettings.radius;
             const height = playerSettings.height - 2 * radius; // Cylinder height
             const playerGeometry = new THREE.CapsuleGeometry(radius, height, 4, 10); // Use CapsuleGeometry
             const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x0055ff, roughness: 0.8 });
             playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
             playerMesh.geometry.computeBoundingBox(); // Important for collision
             playerMesh.castShadow = true;
             playerMesh.position.set(0, playerSettings.height / 2 + 2, 0); // Start slightly elevated
             scene.add(playerMesh);
             collidableObjects.push(playerMesh); // Add player to collidables for testing self-collision if needed (usually not)
             playerCurrentYaw = playerMesh.rotation.y; // Initialize yaw
             playerTargetYaw = playerCurrentYaw;
        }

        function createGround() { // (Keep existing ground function)
             const groundGeometry = new THREE.PlaneGeometry( worldScale, worldScale, 50, 50 );
             groundGeometry.rotateX( - Math.PI / 2 );
             const groundMaterial = new THREE.MeshStandardMaterial( { color: 0x556B2F, roughness: 1.0, metalness: 0.0 } );
             const ground = new THREE.Mesh( groundGeometry, groundMaterial );
             ground.receiveShadow = true;
             scene.add( ground );
             // Add ground to collidables for floor detection
             collidableObjects.push(ground);
        }


        // --- Keep other create... functions (createTrees, createRocks, etc.) as they were ---
        // ... (createTrees, createRocks, createBarrels, createBuildings, createWaterBodies, createAnimals, createTallGrass, createScrapMetal)
        // Ensure these functions add meshes to `collidableObjects` if they should block the player.

        function createTrees(count) {
             const trunkHeight = 5 + Math.random() * 3; // Vary height
             const leavesHeight = 6 + Math.random() * 4;
             const trunkRadius = 0.5 + Math.random() * 0.2;
             const leavesRadius = 2.5 + Math.random();

            const trunkGeometry = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, trunkHeight, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // Saddle Brown
            const leavesGeometry = new THREE.ConeGeometry(leavesRadius, leavesHeight, 8);
            const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // Forest Green

            for (let i = 0; i < count; i++) {
                const treeGroup = new THREE.Group();
                const trunk = new THREE.Mesh(trunkGeometry.clone(), trunkMaterial);
                trunk.position.y = trunkHeight / 2;
                trunk.castShadow = true;
                const leaves = new THREE.Mesh(leavesGeometry.clone(), leavesMaterial);
                leaves.position.y = trunkHeight + leavesHeight / 2 - 1; // Adjust overlap
                leaves.castShadow = true;
                treeGroup.add(trunk);
                treeGroup.add(leaves);

                const radius = worldScale * 0.45;
                treeGroup.position.set(
                    (Math.random() - 0.5) * radius * 2,
                    0,
                    (Math.random() - 0.5) * radius * 2
                );
                treeGroup.rotation.y = Math.random() * Math.PI * 2;
                const scale = 0.8 + Math.random() * 0.4;
                treeGroup.scale.set(scale, scale, scale);

                 // Calculate bounding box for the group FOR COLLISION/INTERACTION
                 const box = new THREE.Box3().setFromObject(treeGroup);
                 treeGroup.userData.boundingBox = box; // Store for collision checks


                scene.add(treeGroup);
                // Store interactable object data
                const treeData = {
                    mesh: treeGroup, // Reference the whole group
                    type: 'Tree',
                    data: { health: 100, woodYield: 5 + Math.floor(Math.random() * 5) }
                };
                worldObjects.push(treeData);
                collidableObjects.push(treeGroup); // Add group for collision
            }
        }

                function createRocks(count) {
            const rockGeometry = new THREE.IcosahedronGeometry(1, 0); // Base radius is 1
            const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.8, flatShading: true });

            for (let i = 0; i < count; i++) {
                const rock = new THREE.Mesh(rockGeometry.clone(), rockMaterial);
                const radius = worldScale * 0.48; // Placement radius in the world
                const scale = 0.5 + Math.random() * 1.5;
                const scaleYFactor = 0.8 + Math.random() * 0.4; // Store the random part for Y scale

                rock.scale.set(scale, scale * scaleYFactor, scale); // Apply scale
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);

                rock.position.set(
                    (Math.random() - 0.5) * radius * 2,
                    rock.scale.y * 0.5, // Adjust Y based on the rock's actual vertical scale (original radius was 1)
                    (Math.random() - 0.5) * radius * 2
                 );
                rock.castShadow = true;
                rock.receiveShadow = true;

                scene.add(rock);
                const rockData = {
                     mesh: rock,
                     type: 'Rock',
                     data: { health: 100, stoneYield: 3 + Math.floor(Math.random() * 4) }
                 };
                worldObjects.push(rockData);
                collidableObjects.push(rock);
            }
        }

         function createBarrels(count) {
             const barrelGeometry = new THREE.CylinderGeometry( 0.8, 0.8, 1.5, 16 );
             const barrelMaterial = new THREE.MeshStandardMaterial( { color: 0xCD853F, roughness: 0.6, metalness: 0.2 });

            for (let i = 0; i < count; i++) {
                 const barrel = new THREE.Mesh( barrelGeometry.clone(), barrelMaterial );
                 const radius = worldScale * 0.45;
                 barrel.position.set(
                     (Math.random() - 0.5) * radius * 2,
                     1.5 / 2,
                     (Math.random() - 0.5) * radius * 2
                 );
                 barrel.castShadow = true;
                 barrel.receiveShadow = true;

                 if (Math.random() < 0.2) { // Tip over
                    barrel.rotation.z = Math.PI / 2 * (Math.random() > 0.5 ? 1 : -1);
                    barrel.rotation.y = Math.random() * Math.PI * 2;
                    barrel.position.y = 0.8;
                 }

                 scene.add(barrel);
                 const barrelData = {
                     mesh: barrel,
                     type: 'Barrel',
                     data: { searched: false, lootTable: ['Scrap Metal', 'Nails', 'Rope', null] } // Example loot, null means chance of nothing
                 };
                worldObjects.push(barrelData);
                // Barrels not collidable
            }
        }

         function createBuildings(count) {
             const buildingMaterial = new THREE.MeshStandardMaterial({ color: 0xAAAAAA, roughness: 0.9 });
             const crateMaterial = new THREE.MeshStandardMaterial({ color: 0xDEB887 }); // BurlyWood
             const crateGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);

             for (let i = 0; i < count; i++) {
                 const width = 8 + Math.random() * 12;
                 const height = 10 + Math.random() * 10;
                 const depth = 8 + Math.random() * 12;
                 const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                 const building = new THREE.Mesh(buildingGeometry, buildingMaterial);

                 const radius = worldScale * 0.4;
                 building.position.set(
                     (Math.random() - 0.5) * radius * 2,
                     height / 2,
                     (Math.random() - 0.5) * radius * 2
                 );
                 building.castShadow = true;
                 building.receiveShadow = true;

                 scene.add(building);
                 collidableObjects.push(building); // Buildings are obstacles

                 // Add searchable crates inside
                 const numCrates = 1 + Math.floor(Math.random() * 3);
                 for (let j = 0; j < numCrates; j++) {
                     const crate = new THREE.Mesh(crateGeometry.clone(), crateMaterial);
                     crate.position.set(
                         building.position.x + (Math.random() - 0.5) * (width * 0.7),
                         1.5 / 2, // On the floor
                         building.position.z + (Math.random() - 0.5) * (depth * 0.7)
                     );
                     crate.castShadow = true;
                     crate.receiveShadow = true;
                     crate.rotation.y = Math.random() * Math.PI / 4;

                     scene.add(crate);
                      const crateData = {
                         mesh: crate,
                         type: 'Crate',
                         data: { searched: false, lootTable: ['Raw Meat', 'Scrap Metal', 'Nails', 'Canteen', null, null] } // Better loot chance
                     };
                     worldObjects.push(crateData);
                 }
             }
         }

        function createWaterBodies(count) {
            const waterMaterial = new THREE.MeshStandardMaterial({
                color: 0x4682B4, transparent: true, opacity: 0.75, roughness: 0.2, metalness: 0.1
            });
            for (let i = 0; i < count; i++) {
                const radius = 10 + Math.random() * 15;
                const waterGeometry = new THREE.CircleGeometry(radius, 32);
                waterGeometry.rotateX(-Math.PI / 2);
                const water = new THREE.Mesh(waterGeometry, waterMaterial);
                const placeRadius = worldScale * 0.4;
                 water.position.set(
                     (Math.random() - 0.5) * placeRadius * 2,
                     0.05, // Slightly above ground
                     (Math.random() - 0.5) * placeRadius * 2
                 );
                water.receiveShadow = true;
                scene.add(water);
                 const waterData = {
                     mesh: water,
                     type: 'Water',
                     data: { source: 'Dirty' } // Player needs canteen to collect
                 };
                 worldObjects.push(waterData);
            }
        }

        function createTallGrass(count) {
             const grassMaterial = new THREE.MeshBasicMaterial({ color: 0x3CB371, side: THREE.DoubleSide, transparent: true, opacity: 0.8 }); // Medium Sea Green
             const grassGeometry = new THREE.PlaneGeometry(1, 1.5); // Width, Height

             for (let i = 0; i < count; i++) {
                 const grass = new THREE.Mesh(grassGeometry.clone(), grassMaterial);
                 const radius = worldScale * 0.49;
                 grass.position.set(
                     (Math.random() - 0.5) * radius * 2,
                     1.5 / 2, // Base on ground
                     (Math.random() - 0.5) * radius * 2
                 );
                 // Make grass always face the camera (simple billboard effect) - STILL USEFUL
                 grass.lookAt(camera.position.x, grass.position.y, camera.position.z); // Initial lookAt
                 grass.rotation.x = 0; // Keep it upright
                 grass.rotation.z = 0;
                 grass.userData.isBillboard = true; // Flag for update loop

                 scene.add(grass);
                  const grassData = {
                     mesh: grass,
                     type: 'Tall Grass',
                     data: { yield: 1 }
                 };
                 worldObjects.push(grassData);
             }
         }

         function createScrapMetal(count) {
             const scrapMaterial = new THREE.MeshStandardMaterial({ color: 0x778899, roughness: 0.7, metalness: 0.4 }); // Light Slate Gray
             const scrapGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.7);

             for (let i = 0; i < count; i++) {
                 const scrap = new THREE.Mesh(scrapGeometry.clone(), scrapMaterial);
                 const radius = worldScale * 0.47;
                 const scale = 0.8 + Math.random() * 0.6;
                 scrap.scale.set(scale, scale, scale);
                 scrap.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                 scrap.position.set(
                     (Math.random() - 0.5) * radius * 2,
                     0.1, // Slightly above ground
                     (Math.random() - 0.5) * radius * 2
                 );
                 scrap.castShadow = true;
                 scene.add(scrap);
                  const scrapData = {
                     mesh: scrap,
                     type: 'Scrap Metal',
                     data: { yield: 1 }
                 };
                 worldObjects.push(scrapData);
             }
         }

        function createAnimals(count) {
            const animalGeometry = new THREE.BoxGeometry(2, 1, 3);
            const animalMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D }); // Sienna

            for (let i = 0; i < count; i++) {
                const animal = new THREE.Mesh(animalGeometry.clone(), animalMaterial);
                const radius = worldScale * 0.45;
                 animal.position.set(
                     (Math.random() - 0.5) * radius * 2,
                     0.5, // Base height
                     (Math.random() - 0.5) * radius * 2
                 );
                animal.castShadow = true;
                animal.receiveShadow = true;
                animal.rotation.y = Math.random() * Math.PI * 2;

                scene.add(animal);
                 const animalData = {
                     mesh: animal,
                     type: 'Animal',
                     data: { health: 50, loot: { 'Raw Meat': 2, 'Leather': 1, 'Fat': 1 } }
                 };
                worldObjects.push(animalData);
                 animals.push({ mesh: animal, state: 'idle', targetPosition: null, speed: 0.5 + Math.random() });
                 collidableObjects.push(animal); // Make animals collidable
            }
        }


        // --- Core Game Loop & Logic ---

        function animate() {
            if (!gameStarted) return; // Don't run if settings screen is up

            requestAnimationFrame( animate );
            const time = performance.now();
            const delta = Math.min(0.1, ( time - prevTime ) / 1000); // Clamp delta time to avoid large jumps

            // Update billboards to face camera
            worldObjects.forEach(obj => {
                if (obj.mesh.userData.isBillboard) {
                    obj.mesh.lookAt(camera.position.x, obj.mesh.position.y, camera.position.z);
                }
            });

            updateAnimals(delta); // Move animals
            if (controlsActive && !inventoryOpen) {
                handlePlayerMovement(delta); // Handle input, gravity, and collision for the player model
            } else {
                 // Apply damping even when controls inactive/inventory open? Optional.
                 playerVelocity.x -= playerVelocity.x * 10.0 * delta;
                 playerVelocity.z -= playerVelocity.z * 10.0 * delta;
                 // Gravity still applies if in air
                 if(playerMesh.position.y > playerSettings.height / 2) { // Basic ground check
                    playerVelocity.y -= 9.8 * 20.0 * delta; // Simplified gravity
                    playerMesh.position.y += playerVelocity.y * delta;
                    if(playerMesh.position.y < playerSettings.height / 2) {
                         playerMesh.position.y = playerSettings.height / 2;
                         playerVelocity.y = 0;
                         canJump = true;
                    }
                 }
            }

            updateCamera(delta); // Update camera position and orientation
            updateInteractionPrompt(); // Check what player is looking at

            prevTime = time;
            renderer.render( scene, camera );
        }

        function handlePlayerMovement(delta) {
             const moveSpeed = playerSettings.speed;
             const damping = 10.0;
             const gravity = 9.8 * 20.0; // Adjusted gravity force

            // --- Apply damping ---
            playerVelocity.x -= playerVelocity.x * damping * delta;
            playerVelocity.z -= playerVelocity.z * damping * delta;

            // --- Apply gravity ---
            playerVelocity.y -= gravity * delta;

            // --- Calculate movement direction based on player's current facing direction ---
             playerDirection.z = Number( moveForward ) - Number( moveBackward );
             playerDirection.x = Number( moveRight ) - Number( moveLeft );
             playerDirection.normalize(); // Ensures consistent speed diagonally

             // Get the player's forward and right vectors based on their current Y rotation (yaw)
             const forwardVector = new THREE.Vector3();
             playerMesh.getWorldDirection(forwardVector); // Gets vector player mesh is pointing
             forwardVector.y = 0; // Project onto XZ plane
             forwardVector.normalize();
             const rightVector = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), forwardVector).normalize();

             // Calculate velocity change from input
             let moveX = 0;
             let moveZ = 0;
             if ( moveForward || moveBackward ) {
                 const forwardMove = forwardVector.multiplyScalar(playerDirection.z * moveSpeed * delta);
                 moveX += forwardMove.x;
                 moveZ += forwardMove.z;
             }
             if ( moveLeft || moveRight ) {
                  const rightMove = rightVector.multiplyScalar(playerDirection.x * moveSpeed * delta);
                  moveX += rightMove.x;
                  moveZ += rightMove.z;
             }

             playerVelocity.x += moveX / delta; // Add as acceleration, damping will handle speed limit
             playerVelocity.z += moveZ / delta;

             // --- Handle Jumping ---
             if ( isJumping && canJump ) {
                 playerVelocity.y += playerSettings.jumpHeight;
                 canJump = false;
                 isJumping = false;
             }


             // --- Collision Detection & Resolution (Simplified AABB) ---
             // Calculate potential next position
             let nextPos = playerMesh.position.clone();
             nextPos.x += playerVelocity.x * delta;
             nextPos.y += playerVelocity.y * delta;
             nextPos.z += playerVelocity.z * delta;

              // Create Player Bounding Box at potential next position
              // Capsule approximation: use height/radius
              const playerHalfHeight = playerSettings.height / 2;
              const playerRadius = playerSettings.radius;
              const playerBox = new THREE.Box3(
                  new THREE.Vector3(nextPos.x - playerRadius, nextPos.y - playerHalfHeight + playerRadius, nextPos.z - playerRadius), // Min point approx.
                  new THREE.Vector3(nextPos.x + playerRadius, nextPos.y + playerHalfHeight - playerRadius, nextPos.z + playerRadius)  // Max point approx.
              );


             let onGround = false;
             let collisionDetected = false;

             // Update world matrices and bounding boxes for collidables
             collidableObjects.forEach(obj => {
                  if (obj === playerMesh) return; // Don't collide with self

                  if (!obj.userData.boundingBox) { // Pre-calculate if missing
                      obj.updateMatrixWorld(true);
                      if (obj instanceof THREE.Group) {
                          obj.userData.boundingBox = new THREE.Box3().setFromObject(obj);
                      } else if (obj.geometry) { // Check geometry exists (like ground plane)
                          if (!obj.geometry.boundingBox) obj.geometry.computeBoundingBox();
                          obj.userData.boundingBox = obj.geometry.boundingBox.clone().applyMatrix4(obj.matrixWorld);
                      }
                  }

                  if(obj.userData.boundingBox && playerBox.intersectsBox(obj.userData.boundingBox)) {
                      collisionDetected = true;

                       // Simple resolution: Stop movement towards the obstacle
                       // More complex: Calculate penetration depth and push back

                       // Check Y collision (landing) - very basic check
                       const playerFeetY = nextPos.y - playerHalfHeight;
                       const objectTopY = obj.userData.boundingBox.max.y;

                       if (playerVelocity.y <= 0 && playerFeetY <= objectTopY + 0.1 && playerFeetY >= objectTopY - 0.5) { // Landed on top? (Tolerance needed)
                            playerVelocity.y = 0;
                            nextPos.y = objectTopY + playerHalfHeight; // Place feet on surface
                            onGround = true;
                            canJump = true;
                       } else {
                           // Basic Wall collision: stop movement for now
                           // A better system would check which axis has overlap and only stop that component
                            playerVelocity.x = 0; // Simplistic stop
                            playerVelocity.z = 0; // Simplistic stop
                            // Revert potential position change due to collision (crude)
                            nextPos.x = playerMesh.position.x;
                            nextPos.z = playerMesh.position.z;
                       }
                  }
             });

             // --- Apply Final Position ---
             playerMesh.position.x += playerVelocity.x * delta;
             playerMesh.position.y += playerVelocity.y * delta; // Apply vertical movement separately after ground check
             playerMesh.position.z += playerVelocity.z * delta;

             // --- Update Ground State ---
             if (!onGround && playerMesh.position.y <= playerHalfHeight + 0.01) { // Check ground plane if no other object collision
                 playerVelocity.y = 0;
                 playerMesh.position.y = playerHalfHeight;
                 canJump = true;
             }

             // --- Update Player Rotation ---
              // Smoothly rotate player model towards camera yaw
              const yawDiff = THREE.MathUtils.lerp(0, playerTargetYaw - playerCurrentYaw, 0.1); // Smoothing factor
              playerCurrentYaw += yawDiff;
              playerMesh.rotation.y = playerCurrentYaw;
        }

        function updateCamera(delta) {
            if (!playerMesh) return;

            // Calculate desired camera position based on player's position and yaw/pitch
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationY(playerTargetYaw); // Rotate around player's target yaw

            const rotatedOffset = cameraOffset.clone().applyMatrix4(rotationMatrix);

            // Adjust vertical position based on pitch
            const pitchMatrix = new THREE.Matrix4();
            // Get the camera's right vector to rotate around
            const rightVector = new THREE.Vector3().crossVectors(
                 playerMesh.position.clone().sub(camera.position).normalize(), // Camera backward vector
                 new THREE.Vector3(0, 1, 0) // World up vector
             ).normalize();
             pitchMatrix.makeRotationAxis(rightVector, -cameraPitch); // Rotate pitch around camera's local X

            // Apply pitch to the offset (might need refinement based on desired pivot)
            // For simplicity, let's just adjust height directly for now
            rotatedOffset.y = cameraOffset.y + Math.sin(cameraPitch) * cameraOffset.z; // Adjust height based on pitch

             const desiredPosition = playerMesh.position.clone().add(rotatedOffset);

            // Add lookAt offset to player position
             const lookAtPosition = playerMesh.position.clone().add(cameraLookAtOffset);

             // Collision check for camera (simple raycast)
             const cameraRay = new THREE.Raycaster(lookAtPosition, desiredPosition.clone().sub(lookAtPosition).normalize(), 0, cameraOffset.length());
             const cameraObstacles = collidableObjects.filter(o => o !== playerMesh); // Exclude player
             const cameraIntersects = cameraRay.intersectObjects(cameraObstacles, true); // Check recursive

             let finalCameraPosition = desiredPosition;
             if (cameraIntersects.length > 0) {
                 // Move camera closer if obstructed
                 finalCameraPosition = cameraIntersects[0].point.lerp(lookAtPosition, 0.1); // Move slightly away from impact point
             }


            // Smoothly move camera towards the final position
            camera.position.lerp(finalCameraPosition, 0.1); // Smoothing factor

            // Look at the player (with vertical offset)
            camera.lookAt(lookAtPosition);
        }

         function updateAnimals(delta) { // Keep existing animal AI logic
            const wanderDistance = 15;
            const minIdleTime = 2;
            const maxIdleTime = 6;

            animals.forEach(animalData => {
                const animal = animalData.mesh;
                const speed = animalData.speed * delta * 5; // Adjust speed multiplier

                if (animalData.state === 'idle') {
                    if (!animalData.idleTimer) {
                         animalData.idleTimer = minIdleTime + Math.random() * (maxIdleTime - minIdleTime);
                    }
                    animalData.idleTimer -= delta;
                    if (animalData.idleTimer <= 0) {
                        animalData.state = 'wandering';
                        animalData.idleTimer = null;
                        // Pick a random target nearby
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * wanderDistance;
                        animalData.targetPosition = new THREE.Vector3(
                            animal.position.x + Math.cos(angle) * distance,
                            animal.position.y, // Keep same height for simplicity
                            animal.position.z + Math.sin(angle) * distance
                        );
                        // Clamp target position to stay roughly within world bounds
                        const halfScale = worldScale * 0.48;
                         animalData.targetPosition.x = Math.max(-halfScale, Math.min(halfScale, animalData.targetPosition.x));
                         animalData.targetPosition.z = Math.max(-halfScale, Math.min(halfScale, animalData.targetPosition.z));
                    }
                } else if (animalData.state === 'wandering' && animalData.targetPosition) {
                    const directionToTarget = animalData.targetPosition.clone().sub(animal.position);
                    if (directionToTarget.lengthSq() < 1) { // Reached target
                        animalData.state = 'idle';
                        animalData.targetPosition = null;
                    } else {
                        directionToTarget.normalize();
                        animal.position.add(directionToTarget.multiplyScalar(speed));
                        // Basic lookAt - might jitter if target is directly above/below
                        const lookTarget = new THREE.Vector3(animalData.targetPosition.x, animal.position.y, animalData.targetPosition.z);
                        animal.lookAt(lookTarget);

                         // Update bounding box after moving
                         animal.updateMatrixWorld(true);
                          // Recompute bounding box for potential interaction/collision checks if needed
                          if (!animal.userData.boundingBox) animal.userData.boundingBox = new THREE.Box3();
                           animal.userData.boundingBox.setFromObject(animal); // Update box after move

                    }
                }
            });
        }

        function updateInteractionPrompt() {
            if (!controlsActive || inventoryOpen) {
                interactionPrompt.style.display = 'none';
                INTERSECTED = null;
                return;
            }

            raycaster.setFromCamera({ x: 0, y: 0 }, camera); // Ray from center of screen still correct

            // Filter worldObjects to get only their meshes for intersection test
            const intersectableMeshes = worldObjects.map(obj => obj.mesh).filter(mesh => mesh !== playerMesh); // Exclude player mesh
            const intersects = raycaster.intersectObjects(intersectableMeshes, true); // Check descendants

            let foundInteractable = false;
            if (intersects.length > 0) {
                 let closestIntersectedMesh = null;
                 let closestDistance = Infinity;

                 for(const intersect of intersects) {
                     // Trace up hierarchy
                     let currentObj = intersect.object;
                     let rootMesh = null;
                     while(currentObj) {
                         if (intersectableMeshes.includes(currentObj)) {
                             rootMesh = currentObj;
                             break;
                         }
                         currentObj = currentObj.parent;
                     }

                     // Use distance from PLAYER MODEL to object for interaction check
                     if(rootMesh && playerMesh) {
                        const distanceToPlayer = playerMesh.position.distanceTo(intersect.point); // Distance from player center to intersect point
                         if(distanceToPlayer < playerSettings.interactionDistance) {
                             if(distanceToPlayer < closestDistance) { // Find closest interactable to the player
                                 closestDistance = distanceToPlayer;
                                 closestIntersectedMesh = rootMesh;
                             }
                         }
                     }
                 }


                if (closestIntersectedMesh) {
                    const worldObjectData = worldObjects.find(obj => obj.mesh === closestIntersectedMesh);

                    if (worldObjectData) {
                         if ((worldObjectData.type === 'Barrel' || worldObjectData.type === 'Crate') && worldObjectData.data.searched) {
                              // Skip prompt for searched containers
                         } else {
                            interactionPrompt.textContent = `[E] ${getInteractionVerb(worldObjectData.type)}`;
                            interactionPrompt.style.display = 'block';
                            INTERSECTED = worldObjectData;
                            foundInteractable = true;
                         }
                    }
                }
            }

            if (!foundInteractable) {
                interactionPrompt.style.display = 'none';
                INTERSECTED = null;
            }
        }

         // --- Keep other functions (getInteractionVerb, handleInteraction, generateAndShowContainerLoot, removeWorldObject, addItemToInventory, etc.) as they were ---
         // Ensure handleInteraction checks INTERSECTED correctly.
         // Ensure removeWorldObject removes from scene, worldObjects, collidableObjects, animals as appropriate.

         function getInteractionVerb(type) {
             switch (type) {
                 case 'Tree': return 'Chop';
                 case 'Rock': return 'Mine';
                 case 'Tall Grass': return 'Harvest';
                 case 'Scrap Metal': return 'Collect';
                 case 'Barrel': return 'Search';
                 case 'Crate': return 'Search';
                 case 'Animal': return 'Hunt'; // Needs knife/weapon
                 case 'Water': return 'Collect Water'; // Needs canteen
                 case 'Campfire': return 'Use';
                 case 'Forge': return 'Use';
                 case 'Crafting Table': return 'Use';
                 default: return 'Interact';
             }
         }


        function handleInteraction() {
            if (!INTERSECTED || inventoryOpen) return;

            const obj = INTERSECTED;
            const type = obj.type;
            const data = obj.data;
            const equippedItem = quickBar[selectedQuickBarSlot]?.name; // Get name if item exists

            logMessage(`Interacting with ${type}`);

            switch (type) {
                case 'Tree':
                    if (equippedItem === 'Axe') {
                        data.health -= 25; // Damage value
                        logMessage(`Chopped Tree. Health: ${data.health}`);
                        if (data.health <= 0) {
                            logMessage(`Tree felled! Gained ${data.woodYield} Wood.`);
                            addItemToInventory('Wood', data.woodYield);
                            removeWorldObject(obj);
                        }
                    } else {
                        logMessage("Requires an Axe to chop.");
                    }
                    break;
                case 'Rock':
                     if (equippedItem === 'Pickaxe') {
                        data.health -= 20; // Damage value
                        logMessage(`Mined Rock. Health: ${data.health}`);
                        if (data.health <= 0) {
                            logMessage(`Rock broken! Gained ${data.stoneYield} Stone.`);
                            addItemToInventory('Stone', data.stoneYield);
                            removeWorldObject(obj);
                        }
                    } else {
                        logMessage("Requires a Pickaxe to mine.");
                    }
                    break;
                case 'Tall Grass':
                     logMessage(`Harvested ${data.yield} Tall Grass.`);
                     addItemToInventory('Tall Grass', data.yield);
                     removeWorldObject(obj);
                    break;
                 case 'Scrap Metal':
                     logMessage(`Collected ${data.yield} Scrap Metal.`);
                     addItemToInventory('Scrap Metal', data.yield);
                     removeWorldObject(obj);
                    break;
                case 'Animal':
                    if (equippedItem === 'Knife') { // Or Bow, Gun etc.
                         logMessage(`Hunted ${type}. Gained resources.`); // Simplified
                         if (data.loot) {
                             for (const [item, count] of Object.entries(data.loot)) {
                                 addItemToInventory(item, count);
                             }
                         }
                         removeWorldObject(obj); // Remove after hunting
                    } else {
                         logMessage("Requires a weapon (Knife?) to hunt.");
                    }
                    break;
                case 'Barrel':
                case 'Crate':
                    if (!data.searched) {
                        logMessage(`Searching ${type}...`);
                        data.searched = true; // Mark as searched immediately
                        generateAndShowContainerLoot(obj);
                    } else {
                        logMessage(`${type} is empty.`);
                    }
                    break;
                 case 'Water':
                     if (equippedItem === 'Canteen') {
                         logMessage("Collected Dirty Water (placeholder).");
                         // TODO: Manage canteen state
                     } else {
                         logMessage("Requires a Canteen to collect water.");
                     }
                     break;
                 case 'Campfire':
                 case 'Forge':
                 case 'Crafting Table':
                     logMessage(`Using ${type} (placeholder - requires specific UI).`);
                     // TODO: Implement specific UI
                     break;
                default:
                    logMessage(`Cannot interact with ${type} yet.`);
            }
            updateQuickBarUI();
            updateInventoryUI(); // Reflect resource changes
        }

         function generateAndShowContainerLoot(containerObject) {
            currentContainerLoot = {}; // Clear previous container loot
            const lootTable = containerObject.data.lootTable || [];
            const numItems = 1 + Math.floor(Math.random() * 4); // 1 to 4 items

             for (let i = 0; i < numItems; i++) {
                const randomItem = lootTable[Math.floor(Math.random() * lootTable.length)];
                if (randomItem) { // Check if not null
                     const quantity = 1 + Math.floor(Math.random() * 3); // 1 to 3 of the item
                     currentContainerLoot[randomItem] = (currentContainerLoot[randomItem] || 0) + quantity;
                }
            }

            logMessage(`Found items in ${containerObject.type}. Opening Inventory...`);
             currentlyInteractingWith = containerObject; // Store reference to the container object
            openInventory(true); // Open inventory showing the container panel
         }

         function removeWorldObject(objectToRemove) {
             // Remove mesh from scene
             scene.remove(objectToRemove.mesh);

             // Remove from worldObjects array
             const worldIndex = worldObjects.findIndex(obj => obj === objectToRemove);
             if (worldIndex > -1) worldObjects.splice(worldIndex, 1);

             // Remove from collidableObjects array if present
             const collideIndex = collidableObjects.findIndex(mesh => mesh === objectToRemove.mesh);
             if (collideIndex > -1) collidableObjects.splice(collideIndex, 1);

             // Remove from animals array if present
              const animalIndex = animals.findIndex(a => a.mesh === objectToRemove.mesh);
              if (animalIndex > -1) animals.splice(animalIndex, 1);

             INTERSECTED = null; // Clear intersection cache
             interactionPrompt.style.display = 'none';
         }

        // --- Inventory & Crafting Logic (Keep existing functions) ---

        function addItemToInventory(itemName, quantity = 1) {
             if (!itemName || quantity <= 0) return false;
             playerInventory[itemName] = (playerInventory[itemName] || 0) + quantity;
             logMessage(`+${quantity} ${itemName}`, 'success');
             updateInventoryUI(); // Update display
             updateCraftingUI(); // Check if new crafts are possible
             return true;
        }

        function removeItemFromInventory(itemName, quantity = 1) {
            if (!playerInventory[itemName] || playerInventory[itemName] < quantity) {
                return false; // Not enough items
            }
            playerInventory[itemName] -= quantity;
            if (playerInventory[itemName] <= 0) {
                delete playerInventory[itemName];
            }
             logMessage(`-${quantity} ${itemName}`, 'removed');
            updateInventoryUI();
            updateQuickBarUI(); // Item might have been in quickbar
            updateCraftingUI();
            return true;
        }

        function getTotalItemCount(itemName) {
            let count = playerInventory[itemName] || 0;
            quickBar.forEach(item => {
                if (item && item.name === itemName) {
                    count += item.quantity;
                }
            });
            return count;
        }

        function consumeResources(ingredients) {
            // First check if all ingredients are available
            for (const [name, required] of Object.entries(ingredients)) {
                if (getTotalItemCount(name) < required) {
                     logMessage(`Missing ${required - getTotalItemCount(name)} ${name}`, 'error');
                    return false; // Cannot craft
                }
            }

            // If check passes, consume items (prefer quickbar first for simplicity)
             for (const [name, required] of Object.entries(ingredients)) {
                 let remaining = required;
                 // Consume from quick bar
                 for (let i = 0; i < quickBar.length && remaining > 0; i++) {
                    if (quickBar[i] && quickBar[i].name === name) {
                         const take = Math.min(remaining, quickBar[i].quantity);
                         quickBar[i].quantity -= take;
                         remaining -= take;
                         if (quickBar[i].quantity <= 0) {
                             quickBar[i] = null; // Remove if empty
                         }
                     }
                 }
                 // Consume remaining from inventory
                 if (remaining > 0) {
                     if (!removeItemFromInventory(name, remaining)) {
                          console.error(`Inventory inconsistency detected trying to remove ${remaining} ${name}`);
                          return false; // Abort crafting
                     }
                 }
             }
             updateQuickBarUI();
             updateInventoryUI();
             return true; // Resources consumed successfully
        }

        function craftItem(recipeName) {
            const recipe = recipes[recipeName];
            if (!recipe) {
                logMessage(`Unknown recipe: ${recipeName}`, 'error');
                return;
            }
             if (recipe.requires) {
                 logMessage(`Crafting ${recipeName} requires a ${recipe.requires} (not fully implemented).`, 'warning');
                 // TODO: Add check here if player is near the required station
             }

            if (consumeResources(recipe.ingredients)) {
                const outputItem = Object.keys(recipe.output)[0];
                const outputQuantity = recipe.output[outputItem];

                logMessage(`Crafted ${outputQuantity} ${outputItem}!`, 'success');
                 let addedToQuickBar = false;
                 for (let i = 0; i < quickBar.length; i++) {
                     if (quickBar[i] === null) {
                         quickBar[i] = { name: outputItem, quantity: outputQuantity };
                         addedToQuickBar = true;
                         updateQuickBarUI();
                         break;
                     }
                 }
                 if (!addedToQuickBar) {
                    addItemToInventory(outputItem, outputQuantity);
                 }
                 updateCraftingUI(); // Update availability
            } else {
                 logMessage(`Not enough resources to craft ${recipeName}.`, 'error');
            }
        }

        // --- UI Update Functions ---

        function toggleInventory() {
             inventoryOpen = !inventoryOpen;
             inventoryScreen.style.display = inventoryOpen ? 'flex' : 'none';

             if (inventoryOpen) {
                 // controls.unlock(); NO PointerLockControls
                 controlsActive = false; // Deactivate camera controls when inventory open
                 document.body.classList.remove('controls-active'); // Show cursor
                 updateInventoryUI();
                 updateCraftingUI();
                 updateContainerUI();
                 containerGrid.style.display = currentlyInteractingWith ? 'block' : 'none';
             } else {
                 // Re-activate controls on close ONLY if blocker isn't shown (i.e. not paused via ESC)
                 if (blocker.style.display === 'none') {
                     controlsActive = true;
                      document.body.classList.add('controls-active'); // Hide cursor
                 }
                 currentlyInteractingWith = null;
                 currentContainerLoot = null;
             }
         }

         function openInventory(showContainer = false) { // Helper to open specifically
             inventoryOpen = true;
             inventoryScreen.style.display = 'flex';
             controlsActive = false;
             document.body.classList.remove('controls-active'); // Show cursor
             updateInventoryUI();
             updateCraftingUI();
             updateContainerUI();
             containerGrid.style.display = showContainer && currentlyInteractingWith ? 'block' : 'none';
         }


         // --- Keep UI Update functions (updateQuickBarUI, updateInventoryUI, etc.) as they were ---
         // Ensure they correctly reference DOM elements and game state variables.

         function updateQuickBarUI() {
             quickBarDiv.innerHTML = ''; // Clear existing slots
             for (let i = 0; i < quickBar.length; i++) {
                 const slot = document.createElement('div');
                 slot.classList.add('quickBarSlot');
                 if (i === selectedQuickBarSlot) {
                     slot.classList.add('selected');
                 }
                 const item = quickBar[i];
                 if (item) {
                     slot.textContent = item.name.substring(0, 6); // Abbreviate
                     if (item.quantity > 1) {
                          const countSpan = document.createElement('span');
                          countSpan.classList.add('itemCount');
                          countSpan.textContent = item.quantity;
                          slot.appendChild(countSpan);
                     }
                 }
                  slot.dataset.index = i;
                 quickBarDiv.appendChild(slot);
             }
         }

         function updateInventoryUI() {
             if (!inventoryOpen) return; // No need to update if hidden

             inventoryGrid.innerHTML = '<h3>Inventory</h3>'; // Clear existing slots but keep header
             const allItems = { ...playerInventory }; // Combine inventory

             // Create slots for all items
             for (const [name, quantity] of Object.entries(allItems)) {
                 if (quantity <= 0) continue; // Skip items with zero count

                 const slot = document.createElement('div');
                 slot.classList.add('inventorySlot');
                 slot.textContent = name.substring(0, 8); // Abbreviate
                 const countSpan = document.createElement('span');
                 countSpan.classList.add('itemCount');
                 countSpan.textContent = quantity;
                 slot.appendChild(countSpan);

                  slot.dataset.itemName = name; // Store item name for interaction
                  slot.addEventListener('click', (event) => handleInventoryClick(event, name, 'inventory'));

                 inventoryGrid.appendChild(slot);
             }
         }

         function updateCraftingUI() {
             if (!inventoryOpen) return;
             craftingPanel.innerHTML = '<h3>Crafting</h3>';

             for (const [name, recipe] of Object.entries(recipes)) {
                 const itemDiv = document.createElement('div');
                 itemDiv.classList.add('craftingItem');

                 let canCraft = true;
                 let ingredientsString = '';
                 for (const [ingName, ingCount] of Object.entries(recipe.ingredients)) {
                     const have = getTotalItemCount(ingName);
                     if (have < ingCount) canCraft = false;
                     ingredientsString += `${ingName}: ${have}/${ingCount} `;
                 }

                 itemDiv.innerHTML = `${name} <button ${canCraft ? '' : 'disabled'}>Craft</button><span>${ingredientsString.trim()}</span>`;
                 if (recipe.requires) {
                     itemDiv.innerHTML += `<span>Requires: ${recipe.requires}</span>`;
                 }

                 itemDiv.querySelector('button').addEventListener('click', () => craftItem(name));
                 if (!canCraft) {
                      itemDiv.style.opacity = '0.6'; // Dim unavailable crafts
                 }

                 craftingPanel.appendChild(itemDiv);
             }
         }

         function updateContainerUI() {
             if (!inventoryOpen || !currentlyInteractingWith || !currentContainerLoot) {
                 containerGrid.innerHTML = '<h3>Container</h3>'; // Clear or show default state
                 containerGrid.style.display = 'none';
                 return;
             }

             containerGrid.innerHTML = `<h3>${currentlyInteractingWith.type}</h3>`; // Set header
             containerGrid.style.display = 'block';

             if (Object.keys(currentContainerLoot).length === 0) {
                 containerGrid.innerHTML += '<span>(Empty)</span>';
                 return;
             }

             for (const [name, quantity] of Object.entries(currentContainerLoot)) {
                 if (quantity <= 0) continue;

                 const slot = document.createElement('div');
                 slot.classList.add('containerSlot');
                 slot.textContent = name.substring(0, 8);
                 const countSpan = document.createElement('span');
                 countSpan.classList.add('itemCount');
                 countSpan.textContent = quantity;
                 slot.appendChild(countSpan);

                 slot.dataset.itemName = name;
                 slot.addEventListener('click', (event) => handleInventoryClick(event, name, 'container'));

                 containerGrid.appendChild(slot);
             }
         }

        function handleInventoryClick(event, itemName, source) {
             const isShiftClick = event.shiftKey;

             if (isShiftClick) {
                 if (source === 'inventory') {
                      moveFromInventoryToQuickBar(itemName);
                 } else if (source === 'container') {
                     // Move ALL of item stack from container to player inventory on shift-click
                     const quantityToMove = currentContainerLoot[itemName];
                     if (quantityToMove > 0) {
                         moveItemBetweenInventories(itemName, currentContainerLoot, playerInventory, quantityToMove);
                         updateContainerUI();
                         updateInventoryUI();
                         updateCraftingUI(); // Update crafting availability
                     }
                 }
             } else {
                if (source === 'container') {
                    // Move ONE item from container to player inventory on normal click
                    moveItemBetweenInventories(itemName, currentContainerLoot, playerInventory, 1);
                    updateContainerUI();
                    updateInventoryUI();
                    updateCraftingUI();
                 } else {
                    // Handle regular inventory click (e.g., select, use, drop - not implemented)
                    logMessage(`Clicked ${itemName} in ${source}`);
                 }
             }
         }

         function moveItemBetweenInventories(itemName, sourceInv, destInv, quantity) {
             if (!sourceInv[itemName] || sourceInv[itemName] < quantity) return; // Not enough in source

             sourceInv[itemName] -= quantity;
             destInv[itemName] = (destInv[itemName] || 0) + quantity;

             if (sourceInv[itemName] <= 0) {
                 delete sourceInv[itemName];
             }
              logMessage(`Moved ${quantity} ${itemName}`); // Generic message
         }


         function moveFromInventoryToQuickBar(itemName) {
             if (!playerInventory[itemName] || playerInventory[itemName] <= 0) return;

             let quantityToMove = playerInventory[itemName]; // Try to move the whole stack

              let targetSlot = -1;
              for (let i = 0; i < quickBar.length; i++) {
                  if (quickBar[i] === null) {
                      targetSlot = i;
                      break;
                  }
              }

             if (targetSlot !== -1) {
                 quickBar[targetSlot] = { name: itemName, quantity: quantityToMove };
                 removeItemFromInventory(itemName, quantityToMove);
                 logMessage(`Moved ${itemName} to quick bar slot ${targetSlot + 1}`);
                 updateQuickBarUI();
                 updateInventoryUI();
             } else {
                 logMessage("Quick bar is full.", "warning");
             }
         }

         function moveToQuickBar(itemName) { // Helper for initial setup
             if (!playerInventory[itemName] || playerInventory[itemName] <= 0) return;
              let quantityToMove = playerInventory[itemName];
              let moved = false;
              for (let i = 0; i < quickBar.length; i++) {
                 if (quickBar[i] === null) {
                     quickBar[i] = { name: itemName, quantity: quantityToMove };
                     removeItemFromInventory(itemName, quantityToMove);
                     moved = true;
                     break;
                 }
             }
             return moved;
         }


         function selectQuickBarSlot(index) {
             if (index >= 0 && index < quickBar.length) {
                 selectedQuickBarSlot = index;
                 logMessage(`Selected quick slot ${index + 1}: ${quickBar[index]?.name || '(Empty)'}`);
                 updateQuickBarUI(); // Update visual selection
             }
         }

         function logMessage(message, type = 'info') {
             console.log(`[${type.toUpperCase()}] ${message}`); // Log to console as well

             const messageDiv = document.createElement('div');
             messageDiv.classList.add('logMessage');
             messageDiv.textContent = message;

             if (type === 'error') messageDiv.style.color = 'red';
             else if (type === 'success') messageDiv.style.color = 'lime';
             else if (type === 'warning') messageDiv.style.color = 'orange';
             else if (type === 'removed') messageDiv.style.color = 'yellow';

             messageLog.appendChild(messageDiv);
             while (messageLog.children.length > 10) {
                 messageLog.removeChild(messageLog.firstChild);
             }
             messageLog.scrollTop = messageLog.scrollHeight;
         }

        // --- Utility Functions ---

        function onWindowResize() {
            if (!camera || !renderer) return;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }

        function handleLoadError(componentName) {
             // Keep this function for handling Three.js core load errors
             console.error(`${componentName} failed to load. Check the HTTP CDN link.`);
             const errorMsg = `<p style="color: red;">Error: Could not load ${componentName}. Game may not function correctly.</p>`;
             if (blocker) blocker.innerHTML = errorMsg;
             else if (settingsScreen) settingsScreen.innerHTML = errorMsg;
        }

        // --- Final Checks ---
        if (typeof THREE === 'undefined') {
            handleLoadError("Three.js core library");
            document.body.innerHTML = '<p style="color: red; font-family: sans-serif;">Error: Could not load Three.js library. Cannot run example.</p>';
        }

    </script>
</body>
</html>
